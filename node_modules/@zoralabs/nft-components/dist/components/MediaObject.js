"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaObject = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const nft_hooks_1 = require("@zoralabs/nft-hooks");
const useMediaContext_1 = require("../context/useMediaContext");
const MediaObject = ({ contentURI, metadata, isFullPage = false, }) => {
    const [mediaError, setMediaErrorMessage] = react_1.useState();
    const [mediaLoaded, setMediaLoaded] = react_1.useState(false);
    const [firstLoadFailed, setFirstLoadFailed] = react_1.useState(false);
    const setMediaError = react_1.useCallback((error) => {
        if (!firstLoadFailed) {
            setFirstLoadFailed(true);
            return;
        }
        setMediaErrorMessage(error.description || "Error loading content");
    }, []);
    const getURI = () => {
        if (contentURI) {
            if (firstLoadFailed) {
                return contentURI;
            }
            // Replace main fleek instance for zora instance only with Zora NFTs
            return contentURI.replace("ipfs.fleek.co", "zora.fleek.co");
        }
        if (metadata.animation_url && !firstLoadFailed) {
            return metadata.animation_url;
        }
        if (metadata.image) {
            return metadata.image;
        }
        return undefined;
    };
    const uri = getURI();
    const { content } = nft_hooks_1.useNFTContent(uri, metadata.mimeType);
    const { getStyles, mediaRenderers } = useMediaContext_1.useMediaContext();
    const getMediaObjectTag = () => {
        const renderMediaConfig = (mediaRenderer) => {
            const mediaObject = {
                objectProps: {
                    ...getStyles("mediaObject", { mediaLoaded, isFullPage }),
                    src: uri,
                    alt: metadata.description,
                    onError: setMediaError,
                    onLoad: () => setMediaLoaded(true),
                },
                isFullPage,
                mediaLoaded,
                media: content,
            };
            const RendererComponent = mediaRenderer.renderer;
            return {
                hasLoader: mediaRenderer.hasLoader,
                mediaTag: jsx_runtime_1.jsx(RendererComponent, Object.assign({}, mediaObject), void 0),
            };
        };
        const handleMimePrefix = (prefix) => {
            const keysToMatch = Object.keys(mediaRenderers)
                .filter((renderKey) => renderKey.startsWith(prefix))
                .sort(([rendererKeyA, rendererKeyB]) => rendererKeyA.length > rendererKeyB.length ? 1 : -1);
            const mediaRendererKey = keysToMatch.find((key) => `${prefix}${content === null || content === void 0 ? void 0 : content.mimeType}`.startsWith(key)) || "unknown";
            return mediaRenderers[mediaRendererKey];
        };
        // Returns in loading state
        if (!content) {
            return {
                hasLoader: true,
                mediaTag: null,
            };
        }
        // Handles text content types
        if (content.type === "text") {
            return renderMediaConfig(handleMimePrefix("text:"));
        }
        // Loading error rendering
        if (mediaError) {
            return renderMediaConfig(mediaRenderers["error"]);
        }
        // Render content with a URI
        return renderMediaConfig(handleMimePrefix("uri:"));
    };
    const { hasLoader, mediaTag } = getMediaObjectTag();
    return (jsx_runtime_1.jsxs(react_1.Fragment, { children: [mediaTag, hasLoader && (jsx_runtime_1.jsx("div", Object.assign({}, getStyles("mediaLoader", { mediaLoaded, isFullPage }), { children: jsx_runtime_1.jsx("span", { children: "Loading..." }, void 0) }), void 0))] }, void 0));
};
exports.MediaObject = MediaObject;
