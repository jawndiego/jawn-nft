"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Audio = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const useMediaContext_1 = require("../context/useMediaContext");
const useSyncRef_1 = require("../utils/useSyncRef");
const FakeWaveformCanvas = ({ audioRef, setPlaying, }) => {
    const canvasRef = react_1.useRef(null);
    const [width, setWidth] = react_1.useState();
    const updateWidth = react_1.useCallback(() => {
        var _a, _b, _c;
        const newWidth = (_c = (_b = (_a = canvasRef.current) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.width;
        if (newWidth && newWidth !== width) {
            setWidth(newWidth);
        }
    }, [canvasRef.current]);
    react_1.useEffect(() => {
        updateWidth();
        window.addEventListener("resize", updateWidth);
        return () => {
            window.removeEventListener("resize", updateWidth);
        };
    }, [updateWidth]);
    react_1.useEffect(() => {
        updateCanvasLines();
        const updateInterval = setInterval(updateCanvasLines, 1000);
        return () => clearInterval(updateInterval);
    }, [width]);
    const seekAudio = react_1.useCallback((evt) => {
        if (audioRef.current && canvasRef.current && width) {
            const position = (evt.clientX - canvasRef.current.getBoundingClientRect().left) /
                width;
            audioRef.current.currentTime = position * audioRef.current.duration;
            setPlaying(true);
            updateCanvasLines();
        }
    }, [audioRef.current, width]);
    const height = 200;
    const updateCanvasLines = react_1.useCallback(() => {
        if (canvasRef.current && width && audioRef.current) {
            const context = canvasRef.current.getContext("2d");
            if (!context) {
                return;
            }
            context.clearRect(0, 0, width, height);
            for (let i = 0; i < width; i += 5) {
                const sinRnd = Math.sin(i) * 10000;
                const lineHeight = Math.floor(Math.min(Math.sin((i / width) * 0.2) +
                    2 * (sinRnd - Math.floor(sinRnd)) * 40, height));
                if (audioRef.current.currentTime / audioRef.current.duration >
                    i / width) {
                    context.fillStyle = "#333";
                }
                else {
                    context.fillStyle = "#999";
                }
                context.fillRect(i, (height - lineHeight) / 2, 2, lineHeight);
            }
        }
    }, [canvasRef.current, audioRef.current, width]);
    return (jsx_runtime_1.jsx("canvas", { ref: canvasRef, height: height, width: width, onClick: seekAudio }, void 0));
};
exports.Audio = react_1.forwardRef(({ objectProps: { onLoad, ...mediaObject }, mediaLoaded }, ref) => {
    const { getStyles } = useMediaContext_1.useMediaContext();
    const audioRef = react_1.useRef(null);
    useSyncRef_1.useSyncRef(audioRef, ref);
    const [playing, setPlaying] = react_1.useState(false);
    const wrapper = react_1.useRef();
    const togglePlay = react_1.useCallback((evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        if (audioRef.current) {
            // playing ? audioRef.current.pause() : audioRef.current.play();
            setPlaying(!playing);
        }
    }, [audioRef.current, playing]);
    react_1.useEffect(() => {
        if (!audioRef.current) {
            return;
        }
        if (playing) {
            audioRef.current.play();
        }
        else {
            audioRef.current.pause();
        }
    }, [audioRef.current, playing]);
    return (jsx_runtime_1.jsxs("div", Object.assign({ ref: wrapper }, getStyles("mediaAudioWrapper"), { children: [mediaLoaded && (jsx_runtime_1.jsxs(react_1.Fragment, { children: [jsx_runtime_1.jsx("button", Object.assign({ onClick: togglePlay }, getStyles("mediaPlayButton", { playing }), { children: playing ? "Pause" : "Play" }), void 0),
                    jsx_runtime_1.jsx("div", Object.assign({}, getStyles("mediaAudioWaveform"), { children: jsx_runtime_1.jsx(FakeWaveformCanvas, { audioRef: audioRef, setPlaying: setPlaying }, void 0) }), void 0)] }, void 0)),
            jsx_runtime_1.jsx("audio", Object.assign({ loop: true, ref: audioRef, style: { display: "none" }, preload: "auto", onLoadedData: onLoad }, mediaObject), void 0)] }), void 0));
});
