"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaFetchAgent = void 0;
const tslib_1 = require("tslib");
const dataloader_1 = tslib_1.__importDefault(require("dataloader"));
const graphql_request_1 = require("graphql-request");
const RequestError_1 = require("./RequestError");
const urls_1 = require("../constants/urls");
const zora_1 = require("../graph-queries/zora");
const uniswap_1 = require("../graph-queries/uniswap");
const timeouts_1 = require("../constants/timeouts");
const TransformFetchResults_1 = require("./TransformFetchResults");
const FetchWithTimeout_1 = require("./FetchWithTimeout");
/**
 * Internal agent for NFT Hooks to fetch NFT information.
 * Can be used directly for interaction with non-react web frameworks or server frameworks.
 * Uses a cached promise-based API.
 * Fetches from IPFS providers and thegraph.
 */
class MediaFetchAgent {
    constructor(network) {
        this.timeouts = timeouts_1.DEFAULT_NETWORK_TIMEOUTS_MS;
        this.networkId = network;
        this.loaders = {
            mediaLoader: new dataloader_1.default((keys) => this.fetchMediaGraph(keys)),
            currencyLoader: new dataloader_1.default((keys) => this.fetchCurrenciesGraph(keys)),
            usernameLoader: new dataloader_1.default((keys) => this.fetchZoraUsernames(keys)),
        };
    }
    /**
     * Clear all cached responses from metadata, currency, and NFT chain information loaders
     */
    clearCache() {
        Object.values(this.loaders).forEach((loader) => loader.clearAll());
    }
    /**
     * Gets information of currencies and trading prices from uniswap
     * @param currencies list of currency contract ids on ethereum
     * @returns Promise<CurrencyLookupType>
     */
    async loadCurrencies(currencies) {
        const results = await this.loaders.currencyLoader.loadMany(currencies);
        return results.reduce((last, result) => {
            if (!(result instanceof Error)) {
                last[result.token.id] = result;
            }
            return last;
        }, {});
    }
    /**
     * Fetch NFT content or retun URI if content shouild not be fetched
     * @param url NFT Content URL
     * @param contentType string mime type to fetch
     * @returns Promise<MediaContentType> Media content information or URL
     */
    async fetchContent(url, contentType) {
        if (contentType.startsWith('text/')) {
            try {
                const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(url);
                return {
                    text: await response.text(),
                    type: 'text',
                    mimeType: contentType,
                };
            }
            catch (e) {
                throw new RequestError_1.RequestError('Issue fetching IPFS data', e);
            }
        }
        return { uri: url, type: 'uri', mimeType: contentType };
    }
    /**
     * Fetch Content MIME type from content URI
     *
     * @param url IPFS Content URI
     * @returns mime type as a string
     * @throws RequestError
     */
    async fetchContentMimeType(url) {
        const response = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS).fetch(url, {
            method: 'HEAD',
        });
        const header = response.headers.get('content-type');
        if (!header) {
            throw new RequestError_1.RequestError('No content type returned for URI');
        }
        return header;
    }
    /**
     * Get on-chain ZORA NFT ID associated media information
     *
     * @param mediaId ZORA NFT id to retrieve information of
     * @returns Promise<NFTDataType> On-chain NFT data
     */
    async loadZNFTData(mediaId, currencyInfos = {}) {
        const chainInfo = await this.loaders.mediaLoader.load(mediaId);
        if (!chainInfo) {
            throw new RequestError_1.RequestError('Cannot fetch chain information');
        }
        return TransformFetchResults_1.addAuctionInformation(chainInfo, currencyInfos);
    }
    async loadZNFTDataUntransformed(mediaId) {
        return await this.loaders.mediaLoader.load(mediaId);
    }
    /**
     *
     * @param address string address of username to load
     * @returns
     */
    async loadUsername(address) {
        return this.loaders.usernameLoader.load(address.toLowerCase());
    }
    /**
     * Fetch function to retrieve Graph data for matching curated auctions
     * This function is not cached
     *
     * @function fetchReserveAuctions
     * @private
     * @param curatorIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of curated auction results
     */
    async fetchReserveAuctions(curatorIds, isApproved = null, first = 1000, skip = 0) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        let query = zora_1.GET_ALL_AUCTIONS;
        if (curatorIds.length) {
            query = zora_1.GET_AUCTION_BY_CURATOR;
        }
        const response = (await client.request(query, {
            curators: curatorIds.length ? curatorIds : undefined,
            first: first,
            skip: skip,
            approved: isApproved === null ? [true, false] : [isApproved],
        }));
        return response.reserveAuctions;
    }
    /**
     * Internal fetch current auctions by curator
     *
     * @function fetchMediaGraph
     * @private
     * @param mediaIds list of Zora NFT IDs to fetch from the graph datastore
     * @returns mapped transformed list of zora NFT ID data
     */
    async fetchMediaGraph(mediaIds) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_API_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const response = (await client.request(zora_1.GET_MEDIA_QUERY, {
            ids_id: mediaIds,
        }));
        return mediaIds.map((key) => TransformFetchResults_1.transformMediaForKey(response, key, this.networkId));
    }
    /**
     * Fetches zora username information from blockchain addresses for displaying user
     * information.
     *
     * @param addresses string list of addresses to map to Zora usernames
     * @returns list of UsernameResponseType - all fields are optional except address
     */
    async fetchZoraUsernames(addresses) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Zora);
        const response = await fetchWithTimeout.fetch(urls_1.ZORA_USERNAME_API_URL, {
            method: 'POST',
            type: 'cors',
            headers: {
                'content-type': 'application/json',
            },
            body: JSON.stringify({ addresses }),
        });
        const usernames = (await response.json());
        return addresses.map((address) => {
            const foundUsername = usernames.find((username) => username.address.toLowerCase() === address);
            if (foundUsername) {
                return foundUsername;
            }
            return { address };
        });
    }
    /**
     * Internal fetch function to retrieve currency information from TheGraph
     *
     * @function fetchCurrenciesGraph
     * @private
     * @param currencyContracts list of Ethereum addresses of currency contract data to retrieve
     * @returns mapped transformed list of ETH currency mapping data
     */
    async fetchCurrenciesGraph(currencyContracts) {
        const fetchWithTimeout = new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.Graph);
        const client = new graphql_request_1.GraphQLClient(urls_1.THEGRAPH_UNISWAP_URL_BY_NETWORK[this.networkId], {
            fetch: fetchWithTimeout.fetch,
        });
        const currencies = (await client.request(uniswap_1.GET_TOKEN_VALUES_QUERY, {
            currencyContracts,
        }));
        return currencyContracts.map((key) => TransformFetchResults_1.transformCurrencyForKey(currencies, key));
    }
    /**
     * Fetch method to query metadata from IPFS. Not cached
     *
     * @function fetchIPFSMetadataCached
     * @public
     * @param url Metadata Source
     * @returns IPFS Metadata Fetch
     * @throws RequestError
     */
    async fetchIPFSMetadata(url) {
        // TODO(iain): Properly parse metadata from `ourzora/media-metadata-schemas
        const request = await new FetchWithTimeout_1.FetchWithTimeout(this.timeouts.IPFS, 'application/json').fetch(url);
        try {
            return await request.json();
        }
        catch (e) {
            throw new RequestError_1.RequestError('Cannot read JSON metadata from IPFS', e);
        }
    }
}
exports.MediaFetchAgent = MediaFetchAgent;
